// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.0
// source: rpcx/proto/encipher.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RpcEncipher_PublicKey_FullMethodName            = "/encipher.RpcEncipher/PublicKey"
	RpcEncipher_ReadConfig_FullMethodName           = "/encipher.RpcEncipher/ReadConfig"
	RpcEncipher_NextId_FullMethodName               = "/encipher.RpcEncipher/NextId"
	RpcEncipher_Signature_FullMethodName            = "/encipher.RpcEncipher/Signature"
	RpcEncipher_VerifySignature_FullMethodName      = "/encipher.RpcEncipher/VerifySignature"
	RpcEncipher_TokenSignature_FullMethodName       = "/encipher.RpcEncipher/TokenSignature"
	RpcEncipher_TokenVerifySignature_FullMethodName = "/encipher.RpcEncipher/TokenVerifySignature"
	RpcEncipher_AesEncrypt_FullMethodName           = "/encipher.RpcEncipher/AesEncrypt"
	RpcEncipher_AesDecrypt_FullMethodName           = "/encipher.RpcEncipher/AesDecrypt"
	RpcEncipher_EccEncrypt_FullMethodName           = "/encipher.RpcEncipher/EccEncrypt"
	RpcEncipher_EccDecrypt_FullMethodName           = "/encipher.RpcEncipher/EccDecrypt"
	RpcEncipher_EccSignature_FullMethodName         = "/encipher.RpcEncipher/EccSignature"
	RpcEncipher_EccVerifySignature_FullMethodName   = "/encipher.RpcEncipher/EccVerifySignature"
	RpcEncipher_TokenEncrypt_FullMethodName         = "/encipher.RpcEncipher/TokenEncrypt"
	RpcEncipher_TokenDecrypt_FullMethodName         = "/encipher.RpcEncipher/TokenDecrypt"
	RpcEncipher_TokenCreate_FullMethodName          = "/encipher.RpcEncipher/TokenCreate"
	RpcEncipher_TokenVerify_FullMethodName          = "/encipher.RpcEncipher/TokenVerify"
)

// RpcEncipherClient is the client API for RpcEncipher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RpcEncipherClient interface {
	PublicKey(ctx context.Context, in *PublicKeyReq, opts ...grpc.CallOption) (*PublicKeyRes, error)
	ReadConfig(ctx context.Context, in *ReadConfigReq, opts ...grpc.CallOption) (*ReadConfigRes, error)
	NextId(ctx context.Context, in *NextIdReq, opts ...grpc.CallOption) (*NextIdRes, error)
	Signature(ctx context.Context, in *SignatureReq, opts ...grpc.CallOption) (*SignatureRes, error)
	VerifySignature(ctx context.Context, in *VerifySignatureReq, opts ...grpc.CallOption) (*VerifySignatureRes, error)
	TokenSignature(ctx context.Context, in *TokenSignatureReq, opts ...grpc.CallOption) (*TokenSignatureRes, error)
	TokenVerifySignature(ctx context.Context, in *TokenVerifySignatureReq, opts ...grpc.CallOption) (*TokenVerifySignatureRes, error)
	AesEncrypt(ctx context.Context, in *AesEncryptReq, opts ...grpc.CallOption) (*AesEncryptRes, error)
	AesDecrypt(ctx context.Context, in *AesDecryptReq, opts ...grpc.CallOption) (*AesDecryptRes, error)
	EccEncrypt(ctx context.Context, in *EccEncryptReq, opts ...grpc.CallOption) (*EccEncryptRes, error)
	EccDecrypt(ctx context.Context, in *EccDecryptReq, opts ...grpc.CallOption) (*EccDecryptRes, error)
	EccSignature(ctx context.Context, in *EccSignatureReq, opts ...grpc.CallOption) (*EccSignatureRes, error)
	EccVerifySignature(ctx context.Context, in *EccVerifySignatureReq, opts ...grpc.CallOption) (*EccVerifySignatureRes, error)
	TokenEncrypt(ctx context.Context, in *TokenEncryptReq, opts ...grpc.CallOption) (*TokenEncryptRes, error)
	TokenDecrypt(ctx context.Context, in *TokenDecryptReq, opts ...grpc.CallOption) (*TokenDecryptRes, error)
	TokenCreate(ctx context.Context, in *TokenCreateReq, opts ...grpc.CallOption) (*TokenCreateRes, error)
	TokenVerify(ctx context.Context, in *TokenVerifyReq, opts ...grpc.CallOption) (*TokenVerifyRes, error)
}

type rpcEncipherClient struct {
	cc grpc.ClientConnInterface
}

func NewRpcEncipherClient(cc grpc.ClientConnInterface) RpcEncipherClient {
	return &rpcEncipherClient{cc}
}

func (c *rpcEncipherClient) PublicKey(ctx context.Context, in *PublicKeyReq, opts ...grpc.CallOption) (*PublicKeyRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicKeyRes)
	err := c.cc.Invoke(ctx, RpcEncipher_PublicKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) ReadConfig(ctx context.Context, in *ReadConfigReq, opts ...grpc.CallOption) (*ReadConfigRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadConfigRes)
	err := c.cc.Invoke(ctx, RpcEncipher_ReadConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) NextId(ctx context.Context, in *NextIdReq, opts ...grpc.CallOption) (*NextIdRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NextIdRes)
	err := c.cc.Invoke(ctx, RpcEncipher_NextId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) Signature(ctx context.Context, in *SignatureReq, opts ...grpc.CallOption) (*SignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_Signature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) VerifySignature(ctx context.Context, in *VerifySignatureReq, opts ...grpc.CallOption) (*VerifySignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifySignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_VerifySignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenSignature(ctx context.Context, in *TokenSignatureReq, opts ...grpc.CallOption) (*TokenSignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenSignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenVerifySignature(ctx context.Context, in *TokenVerifySignatureReq, opts ...grpc.CallOption) (*TokenVerifySignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenVerifySignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenVerifySignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) AesEncrypt(ctx context.Context, in *AesEncryptReq, opts ...grpc.CallOption) (*AesEncryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AesEncryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_AesEncrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) AesDecrypt(ctx context.Context, in *AesDecryptReq, opts ...grpc.CallOption) (*AesDecryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AesDecryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_AesDecrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) EccEncrypt(ctx context.Context, in *EccEncryptReq, opts ...grpc.CallOption) (*EccEncryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EccEncryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_EccEncrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) EccDecrypt(ctx context.Context, in *EccDecryptReq, opts ...grpc.CallOption) (*EccDecryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EccDecryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_EccDecrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) EccSignature(ctx context.Context, in *EccSignatureReq, opts ...grpc.CallOption) (*EccSignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EccSignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_EccSignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) EccVerifySignature(ctx context.Context, in *EccVerifySignatureReq, opts ...grpc.CallOption) (*EccVerifySignatureRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EccVerifySignatureRes)
	err := c.cc.Invoke(ctx, RpcEncipher_EccVerifySignature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenEncrypt(ctx context.Context, in *TokenEncryptReq, opts ...grpc.CallOption) (*TokenEncryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenEncryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenEncrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenDecrypt(ctx context.Context, in *TokenDecryptReq, opts ...grpc.CallOption) (*TokenDecryptRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenDecryptRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenDecrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenCreate(ctx context.Context, in *TokenCreateReq, opts ...grpc.CallOption) (*TokenCreateRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenCreateRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcEncipherClient) TokenVerify(ctx context.Context, in *TokenVerifyReq, opts ...grpc.CallOption) (*TokenVerifyRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenVerifyRes)
	err := c.cc.Invoke(ctx, RpcEncipher_TokenVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RpcEncipherServer is the server API for RpcEncipher service.
// All implementations must embed UnimplementedRpcEncipherServer
// for forward compatibility.
type RpcEncipherServer interface {
	PublicKey(context.Context, *PublicKeyReq) (*PublicKeyRes, error)
	ReadConfig(context.Context, *ReadConfigReq) (*ReadConfigRes, error)
	NextId(context.Context, *NextIdReq) (*NextIdRes, error)
	Signature(context.Context, *SignatureReq) (*SignatureRes, error)
	VerifySignature(context.Context, *VerifySignatureReq) (*VerifySignatureRes, error)
	TokenSignature(context.Context, *TokenSignatureReq) (*TokenSignatureRes, error)
	TokenVerifySignature(context.Context, *TokenVerifySignatureReq) (*TokenVerifySignatureRes, error)
	AesEncrypt(context.Context, *AesEncryptReq) (*AesEncryptRes, error)
	AesDecrypt(context.Context, *AesDecryptReq) (*AesDecryptRes, error)
	EccEncrypt(context.Context, *EccEncryptReq) (*EccEncryptRes, error)
	EccDecrypt(context.Context, *EccDecryptReq) (*EccDecryptRes, error)
	EccSignature(context.Context, *EccSignatureReq) (*EccSignatureRes, error)
	EccVerifySignature(context.Context, *EccVerifySignatureReq) (*EccVerifySignatureRes, error)
	TokenEncrypt(context.Context, *TokenEncryptReq) (*TokenEncryptRes, error)
	TokenDecrypt(context.Context, *TokenDecryptReq) (*TokenDecryptRes, error)
	TokenCreate(context.Context, *TokenCreateReq) (*TokenCreateRes, error)
	TokenVerify(context.Context, *TokenVerifyReq) (*TokenVerifyRes, error)
	mustEmbedUnimplementedRpcEncipherServer()
}

// UnimplementedRpcEncipherServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRpcEncipherServer struct{}

func (UnimplementedRpcEncipherServer) PublicKey(context.Context, *PublicKeyReq) (*PublicKeyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKey not implemented")
}
func (UnimplementedRpcEncipherServer) ReadConfig(context.Context, *ReadConfigReq) (*ReadConfigRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadConfig not implemented")
}
func (UnimplementedRpcEncipherServer) NextId(context.Context, *NextIdReq) (*NextIdRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NextId not implemented")
}
func (UnimplementedRpcEncipherServer) Signature(context.Context, *SignatureReq) (*SignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signature not implemented")
}
func (UnimplementedRpcEncipherServer) VerifySignature(context.Context, *VerifySignatureReq) (*VerifySignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifySignature not implemented")
}
func (UnimplementedRpcEncipherServer) TokenSignature(context.Context, *TokenSignatureReq) (*TokenSignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenSignature not implemented")
}
func (UnimplementedRpcEncipherServer) TokenVerifySignature(context.Context, *TokenVerifySignatureReq) (*TokenVerifySignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenVerifySignature not implemented")
}
func (UnimplementedRpcEncipherServer) AesEncrypt(context.Context, *AesEncryptReq) (*AesEncryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AesEncrypt not implemented")
}
func (UnimplementedRpcEncipherServer) AesDecrypt(context.Context, *AesDecryptReq) (*AesDecryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AesDecrypt not implemented")
}
func (UnimplementedRpcEncipherServer) EccEncrypt(context.Context, *EccEncryptReq) (*EccEncryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EccEncrypt not implemented")
}
func (UnimplementedRpcEncipherServer) EccDecrypt(context.Context, *EccDecryptReq) (*EccDecryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EccDecrypt not implemented")
}
func (UnimplementedRpcEncipherServer) EccSignature(context.Context, *EccSignatureReq) (*EccSignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EccSignature not implemented")
}
func (UnimplementedRpcEncipherServer) EccVerifySignature(context.Context, *EccVerifySignatureReq) (*EccVerifySignatureRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EccVerifySignature not implemented")
}
func (UnimplementedRpcEncipherServer) TokenEncrypt(context.Context, *TokenEncryptReq) (*TokenEncryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenEncrypt not implemented")
}
func (UnimplementedRpcEncipherServer) TokenDecrypt(context.Context, *TokenDecryptReq) (*TokenDecryptRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenDecrypt not implemented")
}
func (UnimplementedRpcEncipherServer) TokenCreate(context.Context, *TokenCreateReq) (*TokenCreateRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenCreate not implemented")
}
func (UnimplementedRpcEncipherServer) TokenVerify(context.Context, *TokenVerifyReq) (*TokenVerifyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenVerify not implemented")
}
func (UnimplementedRpcEncipherServer) mustEmbedUnimplementedRpcEncipherServer() {}
func (UnimplementedRpcEncipherServer) testEmbeddedByValue()                     {}

// UnsafeRpcEncipherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RpcEncipherServer will
// result in compilation errors.
type UnsafeRpcEncipherServer interface {
	mustEmbedUnimplementedRpcEncipherServer()
}

func RegisterRpcEncipherServer(s grpc.ServiceRegistrar, srv RpcEncipherServer) {
	// If the following call pancis, it indicates UnimplementedRpcEncipherServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RpcEncipher_ServiceDesc, srv)
}

func _RpcEncipher_PublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).PublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_PublicKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).PublicKey(ctx, req.(*PublicKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_ReadConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).ReadConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_ReadConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).ReadConfig(ctx, req.(*ReadConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_NextId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).NextId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_NextId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).NextId(ctx, req.(*NextIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_Signature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).Signature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_Signature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).Signature(ctx, req.(*SignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_VerifySignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifySignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).VerifySignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_VerifySignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).VerifySignature(ctx, req.(*VerifySignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenSignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenSignature(ctx, req.(*TokenSignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenVerifySignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenVerifySignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenVerifySignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenVerifySignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenVerifySignature(ctx, req.(*TokenVerifySignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_AesEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AesEncryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).AesEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_AesEncrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).AesEncrypt(ctx, req.(*AesEncryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_AesDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AesDecryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).AesDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_AesDecrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).AesDecrypt(ctx, req.(*AesDecryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_EccEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EccEncryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).EccEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_EccEncrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).EccEncrypt(ctx, req.(*EccEncryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_EccDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EccDecryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).EccDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_EccDecrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).EccDecrypt(ctx, req.(*EccDecryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_EccSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EccSignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).EccSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_EccSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).EccSignature(ctx, req.(*EccSignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_EccVerifySignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EccVerifySignatureReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).EccVerifySignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_EccVerifySignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).EccVerifySignature(ctx, req.(*EccVerifySignatureReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenEncryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenEncrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenEncrypt(ctx, req.(*TokenEncryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenDecryptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenDecrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenDecrypt(ctx, req.(*TokenDecryptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenCreate(ctx, req.(*TokenCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcEncipher_TokenVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcEncipherServer).TokenVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RpcEncipher_TokenVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcEncipherServer).TokenVerify(ctx, req.(*TokenVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RpcEncipher_ServiceDesc is the grpc.ServiceDesc for RpcEncipher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RpcEncipher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "encipher.RpcEncipher",
	HandlerType: (*RpcEncipherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PublicKey",
			Handler:    _RpcEncipher_PublicKey_Handler,
		},
		{
			MethodName: "ReadConfig",
			Handler:    _RpcEncipher_ReadConfig_Handler,
		},
		{
			MethodName: "NextId",
			Handler:    _RpcEncipher_NextId_Handler,
		},
		{
			MethodName: "Signature",
			Handler:    _RpcEncipher_Signature_Handler,
		},
		{
			MethodName: "VerifySignature",
			Handler:    _RpcEncipher_VerifySignature_Handler,
		},
		{
			MethodName: "TokenSignature",
			Handler:    _RpcEncipher_TokenSignature_Handler,
		},
		{
			MethodName: "TokenVerifySignature",
			Handler:    _RpcEncipher_TokenVerifySignature_Handler,
		},
		{
			MethodName: "AesEncrypt",
			Handler:    _RpcEncipher_AesEncrypt_Handler,
		},
		{
			MethodName: "AesDecrypt",
			Handler:    _RpcEncipher_AesDecrypt_Handler,
		},
		{
			MethodName: "EccEncrypt",
			Handler:    _RpcEncipher_EccEncrypt_Handler,
		},
		{
			MethodName: "EccDecrypt",
			Handler:    _RpcEncipher_EccDecrypt_Handler,
		},
		{
			MethodName: "EccSignature",
			Handler:    _RpcEncipher_EccSignature_Handler,
		},
		{
			MethodName: "EccVerifySignature",
			Handler:    _RpcEncipher_EccVerifySignature_Handler,
		},
		{
			MethodName: "TokenEncrypt",
			Handler:    _RpcEncipher_TokenEncrypt_Handler,
		},
		{
			MethodName: "TokenDecrypt",
			Handler:    _RpcEncipher_TokenDecrypt_Handler,
		},
		{
			MethodName: "TokenCreate",
			Handler:    _RpcEncipher_TokenCreate_Handler,
		},
		{
			MethodName: "TokenVerify",
			Handler:    _RpcEncipher_TokenVerify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpcx/proto/encipher.proto",
}
